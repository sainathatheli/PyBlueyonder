DATA TYPES
========
Data Type represents the type of data present inside a variable.
In Python we are not required to specify the type explicitly. Based on value provided,the type will be assigned automatically.
Hence Python is dynamically Typed Language.
Python contains the following inbuilt data types
1) Int
2) Float
3) Complex
4) Bool
5) Str
6) Bytes
7) Bytearray
8) Range
9) List
10) Tuple
11) Set
12) Frozense
13)dict
14)None

Note: Python contains several inbuilt functions

1) type()
to check the type of variable

2) id()
to get address of object

3) print()
to print the value

In Python everything is an Object


int Data Type:
============
We can use int data type to represent whole numbers (integral values)

Eg: a = 10

type(a) #int

Note:
======
In Python2 we have long data type to represent very large integral values.
But in Python3 there is no long type explicitly and we can represent long values also by using int type .


 Float Data Type:
==================
We can use float data type to represent floating point values (decimal values)
 Eg: f = 1.234
 type(f) # float

We can also represent floating point values by using exponential form 
(Scientific Notation)

 Eg: f = 1.2e3  instead of 'e' we can use 'E'
 print(f) 1200.0

The main advantage of exponential form is we can represent big values in less 
memory.


Complex Data Type:
==================
A complex number is of the form
real + imaginarypart
Ex: a + bj

‘a’ and ‘b’ contain Intergers OR Floating Point Values

 Eg: 
  e=3 + 5j
  type(e)
 10 + 5.5j
 0.5 + 0.1


In the real part if we use int value then we can specify that either by decimal, octal,binary or hexa decimal form.

But imaginary part should be specified only by using decimal form.

a=0B11+5j 
 print(a) 
(3+5j) 

a=3+0B11j 
SyntaxError: invalid syntax


Even we can perform operations on complex type values.
>>> a=10+1.5j 
>>> b=20+2.5j 
>>> c=a+b 
>>> print(c) # (30+4j) 

Note: Complex data type has some inbuilt attributes to retrieve the real part and 
imaginary part

c = 10.5+3.6j
c.real  10.5
c.imag  3.6

We can use complex type generally in scientific Applications and electrical engineering Applications.


bool Data Type:
=================
We can use this data type to represent boolean values.
The only allowed values for this data type are:
True and False

Internally Python represents True as 1 and False as 0
 
b = True
type(b) bool

Eg:
a = 10
b = 20
c = a<b
print(c)  True

str Data Type:
==============
str represents String data type.

A String is a sequence of characters enclosed within single quotes or double 
quotes.

s1='durga'
s2="durga"


Note:=
=======
In Python the following data types are considered as Fundamental Data types
int 
float
complex
bool
str

TYPE CASTING
=============
We can convert one type value to another type. This conversion is called Typecasting 
or Type coersion.

The following are various inbuilt functions for type casting.
1) int()
2) float()
3) complex()
4) bool()

int():
======
 We can use this function to convert values from other types to int

float():
========
 We can use float() function to convert other type values to float type.


In python we have 33 reserve keywords
import keyword
keyword.kwlist



What is String?
============
Any sequence of characters within either single quotes or double quotes is considered as a String.
Syntax:
s = 'sainath'
s = "sainath"

Note:
======
In most of other languges like C, C++, Java, a single character with in single quotes 
is treated as char data type value. 

But in Python we are not having char data type.Hence it 
is treated as String only.
Eg:
>>> ch = 'a'
>>> type(ch)
<class 'str'>


How to define multi-line String Literals?

We can define multi-line String literals by using triple single or double quotes.
Eg:
>>> s = '''Blueyondersolutions'''

We can also use triple quotes to use single quotes or double quotes as symbol inside 
String literal

1) s = 'This is ' single quote symbol'  Invalid
2) s = 'This is \' single quote symbol'  Valid
3) s = "This is ' single quote symbol"  Valid
4) s = 'This is " double quotes symbol'  Valid
5) s = 'The "Python Notes" by 'blue' is very helpful'  Invalid
6) s = "The "Python Notes" by 'blue' is very helpful"  Invalid
7) s = 'The \"Python Notes\" by \'blue\' is very helpful'  Valid
8) s = '''The "Python Notes" by 'blue' is very helpful'''  Valid


How to Access Characters of a String?
======================================
We can access characters of a string by using the following ways.
1) By using index
2) By using slice operator

1)Accessing Characters By using Index:

Python supports both +ve and -ve Index.
+ve Index means Left to Right (Forward Direction)
-ve Index means Right to Left (Backward Direction)

Eg: s = 'durga'
1) >>> s='durga' 
2) >>> s[0] 
3) 'd' 
4) >>> s[4] 
5) 'a' 
6) >>> s[-1] 
7) 'a' 
8) >>> s[10] 

IndexError: string index out of range

Note: If we are trying to access characters of a string with out of range index then we will get error saying: IndexError


2)Accessing Characters by using Slice Operator:
===============================================
Syntax: s[bEginindex:endindex:step]

Begin Index: From where we have to consider slice (substring)
End Index: We have to terminate the slice (substring) at endindex-1 
Step: Incremented Value.

Note:
If we are not specifying bEgin index then it will consider from bEginning of the string.

If we are not specifying end index then it will consider up to end of the string.

The default value for step is 1.


s="Learning Python is very very easy!!!" 
s[1:7:1] #'earnin' 
s[1:7] # 'earnin' 
s[1:7:2] # 'eri' 
s[:7] # 'Learnin' 
s[7:] # 'g Python is very very easy!!!' 
s[::] # 'Learning Python is very very easy!!!' 
s[:] # 'Learning Python is very very easy!!!' 
s[::-1] # '!!!ysae yrev yrev si nohtyP gninraeL'


Behaviour of Slice Operator:
=============================
1) s[bEgin:end:step]
2) Step value can be either +ve or –ve
3) If +ve then it should be forward direction(left to right) and we have to consider     bEgin to end-1
4) If -ve then it should be backward direction (right to left) and we have to consider bEgin to end+1.

***Note:
In the backward direction if end value is -1 then result is always empty.
In the forward direction if end value is 0 then result is always empty.



In Forward Direction:
======================
default value for bEgin: 0
default value for end: length of string
default value for step: +1

In Backward Direction:
=======================
default value for bEgin: -1
default value for end: -(length of string+1)
Note: Either forward or backward direction, we can take both +ve and -ve values for 
bEgin and end index.

Slice Operator Case Study:
====================
1) S = 'abcdefghij'
2) s[1:6:2]  'bdf'
3) s[::1]  'abcdefghij'
4) s[::-1]  'jihgfedcba'
5) s[3:7:-1]  ''
6) s[7:4:-1]  'hgf'
7) s[0:10000:1]  'abcdefghij'
8) s[-4:1:-1]  'gfedc'
9) s[-4:1:-2]  'gec'
10)s[5:0:1]  ''
11)s[9:0:0]  ValueError: slice step cannot be zero
12)s[0:-10:-1]  ''
13)s[0:-11:-1]  'a'
14)s[0:0:1]  ''
15)s[0:-9:-2]  ''
16)s[-5:-9:-2]  'fd'
17)s[10:-1:-1]  ''
18)s[10000:2:-1]  'jihgfed'


Mathematical Operators for String:
==================================
We can apply the following mathematical operators for Strings.
1) + operator for concatenation
2) * operator for repetition 

print("durga"+"rao")  durgarao
print("durga"*2)  durgadurga

Note: Slice operator never raises IndexError

Note: 
1) To use + operator for Strings, compulsory both arguments should be str type.
2) To use * operator for Strings, compulsory one argument should be str and other
argument should be int.

len() in-built Function:
=======================
We can use len() function to find the number of characters present in the string.
Eg:
s = 'durga'
print(len(s))  5

input():
========
input() function can be used to read data directly in our required format.
We are not required to perform type casting.

x = input("Enter Value)
type(x)


Ex:
===
write a python program named add.py to read two inputs from keyboard and perform 
sum of two numbers.


Identifier
==========
A Name in Python Program is called Identifier.
It can be Class Name OR Function Name OR Module Name OR Variable Name.

a = 10

Rules to define Identifiers in Python:

1. The only allowed characters in Python are
  alphabet symbols(either lower case or upper case)

 digits(0 to 9)
 underscore symbol(_)

 By mistake if we are using any other symbol like $ then we will get syntax error.
 cash = 10 -->valid
 ca$h =20 ->incalid

 2. Identifier should not starts with digit
   123total ->invalid
   total123 -> valid
 
 3. Identifiers are case sensitive. Of course Python language is case sensitive language.
  
   total=10
   TOTAL=999
   print(total) #10
   print(TOTAL) #999



Identifier:
===========
1) Alphabet Symbols (Either Upper case OR Lower case)
2) If Identifier is start with Underscore (_) then it indicates it is private.
3) Identifier should not start with Digits.
4) Identifiers are case sensitive.
5) We cannot use reserved words as identifiers
 Eg: def = 10 
6) There is no length limit for Python identifiers. But not recommended to use too 
lengthy identifiers.
7) Dollor ($) Symbol is not allowed in Python

Which of the following are valid Python identifiers?
1) 123total  ->invalid
2) total123 ->valid
3) java2share ->valid
4) ca$h ->invalid
5) _abc_abc_  ->valid
6) def ->invalid
7) if  ->invalid

Note:
1) If identifier starts with _ symbol then it indicates that it is private
2) If identifier starts with __(Two Under Score Symbols) indicating that strongly private identifier.
3) If the identifier starts and ends with two underscore symbols then the identifier is language defined special name, which is also known as magic methods
Eg: __add__


bytes Data Type:
=================
 bytes data type represens a group of byte numbers just like an array.

x = [10,20,30,40] 
b = bytes(x) 
type(b)      #bytes 
print(b[0])   # 10
print(b[-1])   #40 

for i in b : print(i) 

 
Conclusion 1:
The only allowed values for byte data type are 0 to 256. By mistake if we are trying to provide any other values then we will get value error.

Conclusion 2:
Once we creates bytes data type value, we cannot change its values,otherwise we will get TypeError




bytearray Data Type:
====================
bytearray is exactly same as bytes data type except that its elements can be 
modified.

x = [10,20,30,40] 
b = bytearray(x) 
type(b)      #bytearray
print(b[0])   # 10
print(b[-1])   #40 

for i in b : print(i) 

b[0]=50

print(b[0])


Range Data Type:
================
range Data Type represents a sequence of numbers.
The elements present in range Data type are not modifiable. 
i.e range Data type is immutable.

case1 : range(10)
generate numbers from 0 to 9
Eg:
r = range(10)
for i in r : print(i)

case-2: range(10, 20)
generate numbers from 10 to 19
Eg:
r = range(10,20)
for i in r : print(i)


case-3: range(10, 20, 2)
2 means increment value
Eg:
r = range(10,20,2)
for i in r : print(i)

or

for i in range(1,10,2):
	print(i)


We can access elements present in the range Data Type by using index.
Eg:
r = range(10,20)
r[0] 
r[15]  #IndexError: range object index out of range

We cannot modify the values of range data type
Eg:
r[0] = 100
TypeError: 'range' object does not support item assignment


We can create a list of values with range data type

Eg:

l = list(range(10)) 
print(l) 
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




frozenset Data Type:
====================
It is exactly same as set except that it is immutable.
Hence we cannot use add or remove functions.

s=set({"apple","mango","kiwi"})
type(s)

fs = frozenset(s)
print(type(fs))

fs.add("orange")


None Data Type:
================
None means nothing or No value associated.
If the value is not available, then to handle such type of cases None introduced.
It is something like null value in Java.

Eg:
def m1():
 a=10
print(m1())
 None



The following are various important escape characters in python

1)\n  -> newline
2)\t  -> horizontal tab
3)\r   ->carriage return
4)\b   -> backspace
5)\f  -> formfeed
6)\v   -> vertical tab
7)\'  -> single quote
8)\"  ->  double quote
9) \\ ->  back slash symbol

print("BlueYonde solutions")
print("BlueYonde \n solutions")


Operators:
===========
1) Arithmetic Operators:

+  -> addition
-  ->substraction
*  ->multiplication
/  ->Divison
%  ->Module

**  ->exponent or power operator

//  ->floor Division operator

test.py:
========
a=10
b=2
print('a+b=',a+b) 
print('a-b=',a-b)
print('a*b=',a*b)
print('a/b=',a/b)
print('a//b=',a//b)
print('a%b=',a%b)
print('a**b=',a**b)

case 2

a=10.5
b=2
print('a+b=',a+b)
print('a-b=',a-b)
print('a*b=',a*b)
print('a/b=',a/b)
print('a//b=',a//b)
print('a%b=',a%b)
print('a**b=',a**b)

Relational operator:
=====================
 > ->greater thab
 >=  ->greater than equal to
 <   -> less than
 <=  -> less than equal to


a=10
b=2
print(a>b)
print(b>a)
print(True > True) ->False
print(True >= True) ->True
print(False > True) -> False
print(10> True) -> True

Eqaulity Operators:
====================
== ->equal to
!= ->not equal to

print(10=20) -> invalid
print(10==20)-> False
print(10!=20)-> True

Logical Operators:
==================
and
or
not

Boolean types behaviour:
========================
and -> if both arguments are True then only result is True
or  -> if atleast one argument is True the result is True
not ->Complement

x and y:
===========

if x is evaluated to false return x otherwise y
Ex:

10 and 20
0 and 20

if first argument is zero then the result is zero other result is y


x or y:
===========

if x is evaluates to True then result is  x otherwise y
Ex:

10 or 20 ->10
0 or 20 -> 20

not x:
======
if x is evaluates to False then result is True otherwise False

not 10 ->False
not 0 ->True

Assignment operators:
====================
+=  
-=
*=
/=
%=
**=
&=
|=

Eg:
---
x=10
x+=20    or x=x+20
print(x) #30

Eg2:
====
x=10
x&=5
print(x)  #0

Ternary Operator or Conditional Operator:
=========================================
syntax:
 x = firstValue if condition else secondValue

if condition is true then firstvvalue
if condition is false then second value

Ex:
--
a,b=10,20
x=30 if a<b else 40
print(x)

Ex2:
===
Read two number from the keyboard and print minimum value
using ternary condition

sol:

a=int(input("Enter the first number")
b=int(input("Enter the second number))
m=a if a<b else b
print("m value is :",m)


Identity Opertors:
==================
We can use identity operators for address comparison
There are 2 identity operators are available.
1) is
2) is not

if r1 is r2 return True if both r1 and r2 pointing to the same object
if r1 is not r2 return if both r1 and r2 are not pointing to the sameobejct

Note:
-----
is will compare address 
=== will compare content 
Ex:
====
a=10
b=10
c=20

print(id(a))
print(id(b))
print(id(c))
print(a is b) #True
print(a is not b) #False



Membership operators:
====================
we can use membership operators to check whether the given object
present in the given collection(list,set,tuple..).

in ->Returns True if the given object present in the specified collection
not in -> Returns True if the given object not present in the specified collection

Ex:
====
x="hello learning python"

print('h' in x) #True
print('d' in x) #False
print ('d' not in x) #True
print('python in x) #True

l1=["apple","banana","orange","kiwi"]
print("apple in l1) #True
print("grapes" not in l1) #True


Mathematical Functions(math module)
====================================
A module is collection of functions,variables and classess etc.

math module that contains several function to perform mathematical oerations.

import math 

Once we can import the we can call any functions of that module.

import math
print(math.sqrt(16))
print(math.pi) 


some functions of math:
======================
ceil(x)
floor(x)
pow(x,y)
factorial(x)
gcd(x,y)
sqrt(x)
pi


Write a python program to find area of circle.
===============================================
import math
r=16
print("area of circle is ", math.pi*(r**2))



eval()
=======
eval function take a string and evaluate the result.

Ex:
===
x=eval("10+20+30")
print(x) #60

l1= eval(input("enter list"))
print(type(l1))
print(l1)

command Line Arguments:
======================

argv is not array it is a list. it is available in sys module
The arguments which are passing at the time of execution are called command line arguments

Ex:-  py test1.py 20 30

ex:
----
test2.py

from sys import argv
print("The number of command line arguments : ",len(argv))
print("The list of command line arguments:",argv)
print("command line arguments one by one:")
for x in argv:
  print(x)


python test2.y 10 20 30


Ex:
===
write a python program named add.py to read two inputs from keyboard and perform 
sum of two numbers.


Exercise:
=========
1)write  a program to check whether the given number is in 
 between 1 and 100?




Iterative statments:
====================
python supports 2 types of iterative statements.
1)for loop
2)while loop


1) for loop:
------------
if we want to execute some actions for every element present in some
sequence (it may be string or collection).

syntax:
--------
 for in sequecne:
	statements


1)write a program to print hello 10times
2)write a program to display 0 to 10
3)write a program to display odd numbers from 0 to 20
4) write a program to display numbers 10 to 1 in descending order
5)write a program to sum of numbers present inside list

  l1=eval(input("enter the list values"))
  sum=0
  for i in l1:
      sum+=i
  print(sum)


while loop:
===========
if we want to execute a group of statements iteratively 
until some condition false.

syntax:
 while condition :
    body


1)write a program to print 1 to 10
2)write a program to sum of first n number.
sol:
----
n = int(input("enter the n number"))
sum=0  
i=1

while i<=n:
   sum+=i
   i+=1

print("sum of first n number:",sum)


break:
======
we can use break statement inside loop execution based on some condition.


continue:
============
we can use continue statment to skip the current iterationand 
continue the next iteration.

ex1:
----
write a program to print 1 to 10  and skip the 5 iteration

sol:

for i in range(1,11):
    if(i==5):
        continue
    else:
         print(i)

or

while i<=10:
      if i==5:
        i+=1
        continue
    print(i)
    i+=1

loops with else block:
======================
inside loop execution,if break statement not executed,then only
else part will be executed.

else means without break.

cart = [10,20,30,40,50]
for item in cart:
    if item>=50:
      print("we cannot pass the order:")
      break
    print item
else:
    print("all items proccesed successfully")



Exercise:
=========
Write a program to display *'s as Equivalent Triangle.


What does end =’ do in Python?
===============================
The end parameter in the print function is used to add any string. At the end of the output of the print statement in python.

By default, the print function ends with a newline.

Passing the whitespace to the end parameter (end=‘ ‘) indicates that the end character has to be identified by whitespace and not a newline.

For example:
print(“hello”, end=’ ‘)

print(“raju”)



pass keyword:
=============
pass is a keyword in python
in our programming syntactically if block is required
which won't do anything then we can define that empty block with pass keyword.

it an empty statement
it is null statement
it won't do anything


Exercises:
==========
1)Program to reverse internal content of word.

2)write a program to print characters at Oddposition and even position for the
  given string.

3) write a program to merge characters of 2 strings into a single by taking
characters alternatively
  input:
       s1="ravi"
       s2="teja"
   Output: rtaevjia

4)write a program to sort the characters of the string and print first Alphabet
 symbol followed by numeric values.
 input : B4A1D3
 output : ABD134

5)write a program to remove duplicate characters from the given string
  Ex:ABCDABBCDABBBCCDDEEEF
     output: ABCDEF           append(), separator.join()

6)write a program to find the number of occurrence of each character present in
  the given string.
    input : ABBABCDDC
    output : A-2,B-3,C-2,D-2

7)write a program to display and count unique vowels present in the given word.
  using list
  Input: blueyondersoftwaresolutions
    output: u e a i o =>5
    
    vl=['a','e','i','o','u']
    word=input("enter the word")
    found=[]
    for i in word:
	if i in v1:
           if i not in found:
               found.append(i)

    print(found)
    print(len(found))

        
Functions:
==========
We can create set of statements to perform the task.

The main advantage of fucntions is reusaboility.

Python Supports two types of functions:

1) Built in functions
   
id()
type()
print()
input()
eval()
..etc




2) User Defined functions

===========================

The functions which are developed by programmer explicitly according to business 
requriements.

syntax:

def functionNam(parameter):

   # business logic   

  return value


1)write a function to print welcome message.


2)write a  program to define function with one parameter to accept the value 
  from end user

def wish(u):
   print("Welcome to python ",u)


wish('sainath') #calling a function with parameter

2) write a program to perform sum of two numbers using function.

 def addition(a,b):
      c=a+b;
      print("sum of two numbers is ",c)

3) write a progra  to perform sum of two numbers and return the sum value.



4) write a program tp check whether the given number is even or
   odd using function.
   


 def addition(a,b):
      c=a+b;
      print("sum of two numbers is ",c)


addition(10,40) 

Here: a , b ar formal parameters
      10, 40 are actual parameters.


There ar 4 types are actual arguments are allowed in python.
1)Positional Arguments
2)KeyWord Arguments
3)Default Arugments
4)Variable length Arguments


1) Positional Arguments:
=========================
 These are the arguments passed to function in correct positional order.
 
     def addition(a,b):
      c=a+b;
      print("sum of two numbers is ",c)

     addition(10,40) #calling a function

2)Keyword Arguments:
====================
  we can pass arguments values by keyword i.e by parameter name.

      def wish(name,msg):
          print("hello",name,msg)

      wish(name="raju",,msg="hi")
      wish(msg="good mrng",name="siddu")
      wish("raju",msg="welcome to functions")# valid
      wish(name="venkat","helloword") # not valid

Note:
-----
position argument followed by keyword argrument is valid.

3) Default Arguments:
====================

      def sayHello(name="guest"):
          print("welcome to function ",name)


     sayHello("veeru") 
      sayHello()  

4)Variable length Arguments:
============================
we can declare a variable  length arguments with * symbol as follows
def f1(*n)

we can call this function by passing any number of arguments including 
zero number.

Internally all these values represented in the form of tuple.

synatx:
=======
        def functionName(*n):

   
     ex:
        def sv(*n):
           for i in n:
               print(i)

  sv(10,20)
  sv(10,30,40,50,60)

1) write a program to perform sum of 10 numbers using variable length argument.

Ex2:
    we can mix positional arguments and variable length arguments

   
    def f1(st,*n):
          print(st)
          for i in n:
             print(i)


Ex3:
=====
    def f2(*n,st):
          print(st)
          for i in n:
             print(i)

   f2(10,30,50,"hi")# invalid

   f2(10,30,50,60,st="hi") #valid

Note:
-----
if function contain first parameter variable length argument ,positional arguments
by calling a function with functionname(variable arguments,keyword arguments).

ex:  f2(10,30,50,60,st="hi") #valid


Variables:
==========
Local variable :is defined inside the function whereas global variable is defined or declared outside of the function. A local variable is always created during the start of function execution. And is destroyed automatically when the function terminates.

global variable: is created when execution starts and terminates when the program execution ends. A global variable is common for all program members but the scope of the local variable is limited to its own function only where it is defined.

Ex:
===
a=10 #global variable

def m1():
    a=343 # local variable
    print(a) 

def m2():
    print(a)


lambda functions:
=================
we can define fucntion by using lamdba keyword

syntax:
=======
lambda parameter1,parameter2..:expression/logic

1)write a program to perform sum of two numbers

s=lambda a,b:a+b
print(type(s))
print("sum of two numbers ",s(10,20))


2) write a program to find biggest of given numbers using lambda fucntion.

     gt = lambda a,b:a if a>b else b

     print("greater number from 10,20 is ",gt(10,20))



filter() function:
===================
we can use filter()function to filter values from the given sequence based on
condition

filter(function,sequence)

Q) program to filter only even numbers from the list by using filter()?
 
without lambda:
===============
def isEven(x):
   if x%2==0:
     return True
   else
     return False

l1=[0,5,10,15,20,25,30]
li=list(filter(isEven,l1)
print(li)

with lambda:
============
l1=[0,5,10,15,20,25,30]
li=list(filter(lambda x:x%2==0,l1))
print(li)



map():
=======
for every element present in the sequence,add some functionalities and 
generate new element based on required format.

map(function,sequence)

ex:
===
every element in the list convert into double

without lambda:
==================
def dl(x):
    return x*x

l1=[4,5,7,8,3]
l2=list(map(dl,l1))
print(l2)

with lambda:
==============
l1=[4,5,7,8,3]
l2=list(map(lambda x:x*x,l1)
print(l2)


Exercises:
==========
1)Define a function which counts vowels and consonant in a word.

2)Define a function that accepts lowercase words and returns uppercase words.

3)Write a function that inputs a number and prints the multiplication table of that number

4)Write a program to print twin primes less than 1000. 
 If two consecutive odd numbers are both prime then they are known as twin primes

5)Write a program to find out the prime factors of a number. 
 Example: prime factors of 56 is  2, 7

6)Write a function that converts a decimal number to binary number

Base Conversions
----------------
bin()     
oct()
hex()
    

Modules:
==========
A group of functions,variables and classes saved to a file.
Every python file(.py) act as a module

if we want to use members of module in programs then we should import that module.
ex: import modulename

we can access members by using modulename
modulename.variable
modulename.function()

Ex:
===
create a python file which contains three functions and one variable

testModule.py
------------
x="hi"

def f1():
	print("we are in f1 function")

def addition(a,b):
	print("sum of two numbers",(a+b))

def sayHell(msg):
	print("hello ",msg)


test.py
=======
import testModule

testModule.f1()
testModule.addition(10,20)
testModule.sayHello("how are you")
print(testModule.x)

or

using aliasing
--------------
import testModule as tm

tm.f1()
tm.addition(10,20)
tm.sayHello("how are you")
print(tm.x)

or
form..import
------------
from testModule import *

f1()
addition(10,20)
sayHello("how are you")
print(x)

or

form..import using specific function
-------------------------------------
from testMoudule import addition

addition(30,40)

or 

form..import using specific function using alias
------------------------------------------------
from testMoudule import addition as a

a(30,40)



Finding Members of module by using dir()function:
====================================================
dir() --> to list out all members of current module.
dir(modulename) -> to list out all members of specified module.


Note:
=====
for every module at the time of execution python interpreter will add some special
properties automatically for internal use.
ex:
print(dir(testModule))
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'addition', 'f1', 'sayHell', 'x']


The special variable __name__
---------------------------------
For every python program, a special varibale __name__ will be added internally.

This variable stores information regarding whether the program is executed as an
individual program or as a module.

if the program executed as an individual program then the value of this variable is 
__main__

if the program executed as a module from some other program then the value of this
variable is the name of module where it is defined.

Hence by using this __name__ variable we can identify whether the program executed
directly or as a module.

Ex:
---
test1.py

def f1():
  	if __name__='__main__':
		print("program executed from the same modeule test.py")
	else:	
		print("program executed from the other module test.py")



packages
=========
It is mechanism to group related modules into a single unit.

package is a folder or directory which represents collection of python modules.

Any folder or directory contains __init__.py file, is considered as a python package.This file can be empty.

A package can contain sub packages also.

The main advantages of packages statement are:
1)we can resolve naming conflicts
2)we can identify our components uniquely
3)it improves modularity of the application

Ex:
---
create one directory named as come, in that directory creat testModule.py.
packages
  |
  |
  |____come  -folder
  |
  |____test.py (outside com folder)
  	|
	|___testModule.py (inside com folder)
        |___ __init__.py (empty file)


testModule.py
------------
x="hi"

def f1():
	print("we are in f1 function")

def addition(a,b):
	print("sum of two numbers",(a+b))

def sayHell(msg):
	print("hello ",msg)


test.py:
========
import com.testModule

com.testModule.f1()
com.testModule.addition(10,20)
com.testModule.sayHello("how are you")
print(com.testModule.x)


or

using alias name
=================
import com.testModule as ct

ct.f1()
ct.addition(10,20)
ct.sayHello("how are you")
print(ct.x)


or
from.. import -->specific members

from com.testModule import addition as a,f1
f1()
a(10,30)

Exception handling:
===================

In any programming language there are 2 types of errors are possible.
1) Syntax Errors
2) Runtime Errors


1)Syntax Errors:
 The errors which occur because of invalid syntax are called syntax errors.
Eg 1:
x = 10
if x == 10
 print "Hello"
SyntaxError: invalid syntax
Eg 2:
print "Hello"
SyntaxError: Missing parentheses in call to 'print'

Note: Programmer is responsible to correct these syntax errors. Once all syntax errors are corrected then only program execution will be started.

2)Runtime Errors:
Also known as exceptions.
While executing the program if something goes wrong because of end user input or 
programming logic or memory problems etc then we will get Runtime Errors.

Eg:
1) print(10/0)  ZeroDivisionError: division by zero
2) print(10/"ten")  TypeError: unsupported operand type(s) for /: 'int' and 'str'
3) x = int(input("Enter Number:"))
print(x)

D:\Python_classes>py test.py
Enter Number:ten
ValueError: invalid literal for int() with base 10: 'ten'

Note: Exception Handling concept applicable for Runtime Errors but not for syntax error


What is Exception?
An unwanted and unexpected event that disturbs normal flow of program is called 
exception.
Eg:
ZeroDivisionError
TypeError
ValueError
FileNotFoundError
..etc

It is highly recommended to handle exceptions. The main objective of exception handling is Graceful Termination of the program (i.e we should not block our resources and we should not miss anything)
We have to define alternative way to continue rest of the program normally.

Eg: For example our programming requirement is reading data from remote file locating 
at London. At runtime if London file is not available then the program should not be 
terminated abnormally. We have to provide local file to continue rest of the program 
normally. This way of defining alternative is nothing but exception handling.

try:
Read Data from Remote File locating at London.
except FileNotFoundError:
use local file and continue rest of the program normally



Every Exception in Python is a class. 

All exception classes are child classes of BaseException.i.e every exception class 
extends BaseException either directly or indirectly. Hence BaseException acts as root 
for Python Exception Hierarchy.

Most of the times being a programmer we have to concentrate Exception and its child 
classes.


Exception Handling by using try-except:
========================================
It is highly recommended to handle exceptions.

The code which may raise exception is called error code and we have to take error code inside try block. The corresponding handling code we have to take inside except block.

try:
 error Code
except XXX:
 Handling code/Alternative Cod



Without try-except:
====================
print("stmt-1") 
print(10/0) 
print("stmt-3") 

Output
=======
stmt-1 
ZeroDivisionError: division by zero 
Abnormal termination/Non-Graceful Termination

With try-except:
----------------
print("stmt-1") 
try: 
print(10/0) 

except ZeroDivisionError: 
print(10/2) 
print("stmt-3") 

output:
-----
stmt-1 
5.0 
stmt-3 
Normal termination/Graceful Termination



Single except Block that can handle Multiple Exceptions:
========================================================
We can write a single except block that can handle multiple different types of exceptions.
except (Exception1,Exception2,exception3,..): OR
except (Exception1,Exception2,exception3,..) as msg :


Default except Block:
=====================
We can use default except block to handle any type of exceptions.
In default except block generally we can print normal error messages.

Syntax: 
 except:
 statements


finally Block:
===============
It is not recommended to maintain clean up code(Resource Deallocating Code or 
Resource Releasing code) inside try block because there is no guarentee for the 
execution of every statement inside try block always.
 
It is not recommended to maintain clean up code inside except block, because if there 
is no exception then except block won't be executed.

Hence we required some place to maintain clean up code which should be executed 
always irrespective of whether exception raised or not raised and whether exception 
handled or not handled. Such type of best place is nothing but finally block.
 
Hence the main purpose of finally block is to maintain clean up code.
try:
 Risky Code
except: 
 Handling Code
finally:
 Cleanup code

The speciality of finally block is it will be executed always whether exception raised or not raised and whether exception handled or not handled


else Block with try-except-finally:
=======================================
We can use else block with try-except-finally blocks.
else block will be executed if and only if there are no exceptions inside try block.

try:
Risky Code
except:
will be executed if exception inside try
else:
will be executed if there is no exception inside try
finally:
will be executed whether exception raised or not raised and handled or not 
handled




1)Predefined Exceptions:

Also known as inbuilt exceptions.
The exceptions which are raised automatically by Python virtual machine whenver a 
particular event occurs are called pre defined exceptions.

Eg 1: Whenever we are trying to perform Division by zero, automatically Python will 
raise ZeroDivisionError.
print(10/0)


Eg 2: Whenever we are trying to convert input value to int type and if input value is 
not int value then Python will raise ValueError automatically
x=int("ten")  ValueError



User Defined Exceptions:
=========================
Also known as Customized Exceptions or Programatic Exceptions
Some time we have to define and raise exceptions explicitly to indicate that something goes wrong, such type of exceptions are called User Defined Exceptions or Customized 
Exceptions

Programmer is responsible to define these exceptions and Python not having any idea 
about these. Hence we have to raise explicitly based on our requirement by using 
"raise" keyword

How to Define and Raise Customized Exceptions:
===============================================
Every exception in Python is a class that extends Exception class either directly or 
indirectly.
Syntax:
 class classname(predefined exception class name):
 def __init__(self,arg):
 self.msg=arg


Exercises:
===========
Write a Python program that opens a file and handles a FileNotFoundError exception if the file does not exist.

Write a Python program that prompts the user to input two numbers and raises a TypeError exception if the inputs are not numerical.


Exercises on Files
===================
1)Write a program that writes 10 random numbers to a file 'numbers.txt'. Each random number should be in the range of 1 through 100(hint use random module-->randominit())

2)Write a program that reads and display all of the numbers stored in the file numbers.txt (created in      question 1) and calculates their total.

3)Write a function, digit_count() in Python that counts and displays the number of digits in the text file named 'sample.txt'. 
For example, if the content of 'sample.txt' is as follows :
The team achieved a milestone in 2023. They completed a multi-million-dollar project ahead of schedule. Stakeholders were impressed with a 98% success rate.

The function should display the output as 6

4)Write a function lines_count() that reads lines from a text file named 'zen.txt' and displays the lines that begin with any vowel. Assume the file contains the following text and already exists on the computer's disk:

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.

The lines_count() function should display the output as:
Explicit is better than implicit.


File Handling:
================

As the part of programming requirement, we have to store our data permanently for 
future purpose. For this requirement we should go for files.

Files are very common permanent storage areas to store our data

Types of Files:

There are 2 types of files

1) Text Files:
 Usually we can use text files to store character data
 Eg: abc.txt

2) Binary Files:
Usually we can use binary files to store binary data like images,video files, audio files etc...

Opening a File:

Before performing any operation (like read or write) on the file,first we have to open that file.
For this we should use Python's inbuilt function open()

But at the time of open, we have to specify mode,which represents the purpose of 
opening file.

f = open(filename, mode)

The allowed modes in Python are

1) r  open an existing file for read operation. The file pointer is positioned at the beginning of the file.If the specified file does not exist then we will get FileNotFoundError.This is default mode.

2) w  open an existing file for write operation. If the file already contains some data then it will be overridden. If the specified file is not already avaialble then this mode will create that file.

3) a  open an existing file for append operation. It won't override existing data.If the specified file is not already avaialble then this mode will create a new file.

4) r+  To read and write data into the file. The previous data in the file will not be deleted.The file pointer is placed at the beginning of the file.

5) w+  To write and read data. It will override existing data.

6) a+  To append and read data from the file.It wont override existing data.

7) x  To open a file in exclusive creation mode for write operation. If the file already exists then we will get FileExistsError.

Note:
=====
All the above modes are applicable for text files. If the above modes suffixed with 'b' then these represents for binary files.
Eg: rb,wb,ab,r+b,w+b,a+b,xb


f = open("abc.txt","w")

We are opening abc.txt file for writing data.

Closing a File:
================

After completing our operations on the file, it is highly recommended to close the file. For this we have to use close() function.

f.close()

Various Properties of File Object:
==================================
Once we opend a file and we got file object, we can get various details related to that file by using its properties.

name  Name of opened file

mode  Mode in which the file is opened

closed  Returns boolean value indicates that file is closed or not

readable() Returns boolean value indicates that whether file is readable or not

writable() Returns boolean value indicates that whether file is writable or not.

f=open("abc.txt",'w') 
print("File Name: ",f.name) 
print("File Mode: ",f.mode) 
print("Is File Readable: ",f.readable()) 
print("Is File Writable: ",f.writable()) 
print("Is File Closed : ",f.closed) 

f.close() 

print("Is File Closed : ",f.closed)




Writing Data to Text Files:
===========================
We can write character data to the text files by using the following 2 methods.
1) write(str)
2) writelines(list of lines)


Exercises:
==========

Write a program to check whether the given files exists or not. If it is exist then print its content.
write a program to print number of lines,words and characters present in the given file (simple.txt).


tell():
=======
it will tell us the current position(file pointer).
current position by default is 0 (file starts at first)

seek():
========
it will tell us to moving cursor pointer(file position)

ex:
----
seeK(17) --it will place the cursor at 17th position


Exercises:
==========
1. Write a function in python to read the content from a text file "poem.txt" line by line and display the same on screen

2.Write a function in python to count the number of lines from a text file "story.txt" which is not starting with an alphabet "T". 

Example: If the file "story.txt" contains the following lines: 
A boy is playing there.
There is a playground.
An aeroplane is in the sky.
The sky is pink.
Alphabets and numbers are allowed in the password.

The function should display the output as 3

3)Write a function in Python to read lines from a text file "notes.txt". Your function should find and display the occurrence of the word "the".
For example: If the content of the file is:
"India is the fastest-growing economy. India is looking for more investments around the globe. The whole world is looking at India as a great market. Most of the Indians can foresee the heights that India is capable of reaching."

The output should be 5

4)Write a function display_words() in python to read lines from a text file "story.txt", and display those words, which are less than 4 characters


5)Write a function last_digit_words() in Python to count the words ending with a digit in a text file "notes.txt". 

For example, if the file content is as follows :
The Computer6 hums softly as I sit with a Book3 in hand, diving into a world of imagination. Outside, my friends gather at House9 and I quickly grab my Pen2 to jot down the address.

The expected output should be:
Number of words ending with a digit are 4  


























 





























   



































