What is Class:  
 
In Python every thing is an object. To create objects we required some Model or Plan or Blue print, which is nothing but class. 

We can write a class to represent properties (attributes) and actions (behaviour) of object. 
 
Properties can be represented by variables 
Actions can be represented by functions or Methods. 
 
Hence class contains both variables and methods. 
 
How to define a Class? 
We can define a class by using class keyword.  
 
Syntax: 
class className: 
  ''' documenttation string '''  
  
variables:instance variables,static and local variables    
methods: instance methods,static methods,class methods 
 
Documentation string represents description of the class. Within the class doc string is always optional. 

We can get doc string by using the following 2 ways. 
 
1)	print(classname.__doc__) 
2)	help(classname) 
 
Example: 
test.py

class Student:
    ''' this class contain student details'''


print(Student.__doc__)

 
Within the Python class we can represent data by using variables.  
 
There are 3 types of variables are allowed. 
  
1)	Instance Variables (Object Level Variables) 
2)	Static Variables (Class Level Variables) 
3)	Local variables (Method Level Variables) 
 
Within the Python class, we can represent operations by using methods. The following are various types of allowed methods  
 
1)	Instance Methods 
2)	Class Methods  
3)	Static Methods 
  
Example for Class: 

class Student:
    '''this class contain student details'''
    def __init__(self):
        self.name="Ramesh"
        self.rollno=1212
        self.marks=40
        print(self.name)
        print(self.rollno)
        print(self.marks)

s=Student() #creating a object
print(type(s))



What is Object: 
Pysical existence of a class is nothing but object. We can create any number of objects for a class. 
 
Syntax to Create Object: referencevariable = classname() 
 
Example: s = Student() 
 
What is Reference Variable? 
The variable which can be used to refer object is called reference variable. 
By using reference variable, we can access properties and methods of object. 
 
Program: Write a Python program to create a Student class and Creates an object to it. Call the method talk() to display student details 
class Student:
    '''this class contain student details'''
    def __init__(self,name,rollno,marks):
        self.name=name
        self.rollno=rollno
        self.marks=marks
        
         def talk(self):   
         print("Hello My Name is:",self.name)   
         print("My Rollno is:",self.rollno)   
         print("My Marks are:",self.marks)   
    
 s1=Student("Ramesh",101,80)   
s1.talk()

   
Output: 
 
Hello My Name is: Ramesh 
My Rollno is: 101 
My Marks are: 80 


                 
Self Variable: 
===================
self is the default variable which is always pointing to current object (like this keyword in Java) 

By using self we can access instance variables and instance methods of object. 
 
Note: 
1)self should be first parameter inside constructor  def __init__(self): 
2)self should be first parameter inside instance methods def talk(self): 


Constructor Concept: 
=======================
Constructor is a special method in python. 

The name of the constructor should be __init__(self) 
Constructor will be executed automatically at the time of object creation. 

The main purpose of constructor is to declare and initialize instance variables. 
Per object constructor will be exeucted only once. 

Constructor can take atleast one argument(atleast self) 
Constructor is optional and if we are not providing any constructor then python will provide default constructor. 
 
Example:  
 Program to demonistrate Constructor will execute only once per Object: 
 
class Student:
    def __init__(self):
        print("constructor execution)

    def display(self):
        print("method execution)

s=Student()
s1=Stundent()
s2=Stundent()

s.display()


Output 
Constructor exeuction... 
Constructor exeuction... 
Constructor exeuction... 
Method execution... 
 
Program: 


class Student:
    def __init__(self,x,y,z):
	self.name=x
	self.rollno=y
        self.marks=z
        print("constructor execution)

    def display(self):
        print("Student Name:{}\nRollNo:{}\nMarks:{}".format(self.name,self.rollno,self.marks))

s=Student("ramesh",101,80)
s.display()

s1=Student("sunny",102,100)
s1.display()


Output 
Student Name:Ramesh 
Rollno:101 
Marks:80 
 
Student Name:Sunny 
Rollno:102 
Marks:100 
 
Differences between Methods and Constructors	 
Method 	                                              Constructor 
1) Name of method can be any name 	       1) Constructor name should be always __init__ 
2) Method will be executed if we call that method 	2) Constructor will be executed automatically at          								the time of object creation. 
3) Per object, method can be called any number of times. 	3) Per object, Constructor will be executed 										only once 
4) Inside method we can write business logic 
 	                               4) Inside Constructor we have to declare andinitialize instance 													variables 


 
Types of Variables: 
 
Inside Python class 3 types of variables are allowed. 
 
1)	Instance Variables (Object Level Variables) 
2)	Static Variables (Class Level Variables) 
3)	Local variables (Method Level Variables) 
 
1) Instance Variables: 
If the value of a variable is varied from object to object, then such type of variables are called instance variables. 

For every object a separate copy of instance variables will be created. 
 
Where we can declare Instance Variables: 
1)	Inside Constructor by using self variable 
2)	Inside Instance Method by using self variable 
3)	Outside of the class by using object reference variable 
 
1)	Inside Constructor by using Self Variable: 
We can declare instance variables inside a constructor by using self keyword. Once we creates object, automatically these variables will be added to the object. 
 
 
Output:  {'eno': 100, 'ename': 'Durga', 'esal': 10000} 
 
2)	Inside Instance Method by using Self Variable: 
We can also declare instance variables inside instance method by using self variable. If any instance variable declared inside instance method, that instance variable will be added once we call taht method. 
 
 
3)	Outside of the Class by using Object Reference Variable: 
We can also add instance variables outside of a class to a particular object. 
 
How to Access Instance Variables: 
We can access instance variables with in the class by using self variable and outside of the class by using object reference. 


class Employee:
   
    def __init__(self,eno,ename,esal):
         self.eno=eno
         self.ename=ename
         self.esal=esal

    def display(self):
         self.address="boston"
         print("EMployee details are :")
         print("EmployeNo is : {} \n EMployee Name is {} \n Employee Sal is                   			{}".format(self.eno,self.ename,self.esal))

e=Employee(1001,"smith",4000)

e.display()


How to delete Instance Variable from the Object: 
=================================================
1)Within a class we can delete instance variable as follows          
      del self.variableName 
 
2)From outside of class we can delete instance variables as follows   
       del objectreference.variableName 

class Test: 
	def __init__(self): 
 		self.a=10 
 		self.b=20 
 		self.c=30 
 		self.d=40 

 	def m1(self): 
  		del self.d 
 
  t=Test() 
  print(t.__dict__) 
  t.m1() 
  print(t.__dict__) 
  del t.c #outside the class
  print(t.__dict__)
 
Output 
{'a': 10, 'b': 20, 'c': 30, 'd': 40} 
{'a': 10, 'b': 20, 'c': 30} 
{'a': 10, 'b': 20} 
 

Note: The instance variables which are deleted from one object,
       will not be deleted from other objects.

class Test: 
   def __init__(self): 
   self.a=10 
   self.b=20 
   self.c=30 
   self.d=40 

t1=Test() 
t2=Test() 
del t1.a 

print(t1.__dict__) 
print(t2.__dict__)  
 
{'b': 20, 'c': 30, 'd': 40} 
{'a': 10, 'b': 20, 'c': 30, 'd': 40} 


 
If we change the values of instance variables of one object then those changes won't be reflected to the remaining objects, because for every object we are separate copy of instance variables are available. 
 
class Test: 
 def __init__(self): 
 self.a=10 
 self.b=20 

t1=Test() 
t1.a=888 
t1.b=999 

t2=Test() 
print('t1:',t1.a,t1.b) 
print('t2:',t2.a,t2.b)

Output 
t1: 888 999 
t2: 10 20 


Static Variables: 
===================
If the value of a variable is not varied from object to object, such type of variables we have to declare with in the class directly but outside of methods. Such types of variables are called Static variables. 

For total class only one copy of static variable will be created and shared by all objects of that class. 

We can access static variables either by class name or by object reference. 
But recommended to use class name. 
 
Instance Variable vs Static Variable: 
Note: In the case of instance variables for every object a seperate copy will be created,but in the case of static variables for total class only one copy will be created and shared by every object of that class. 

class Test: 
   x=10 
  
   def __init__(self): 
    self.y=20 

t1=Test() 
t2=Test() 

print('t1:',t1.x,t1.y) 
print('t2:',t2.x,t2.y) 

Test.x=888 
t1.y=999 

print('t1:',t1.x,t1.y) 
print('t2:',t2.x,t2.y)
 
Output 
t1: 10 20 
t2: 10 20 
t1: 888 999
 t2: 888 20  

Various Places to declare Static Variables: 
1)In general we can declare within the class directly but from out side of any method 
2)Inside constructor by using class name 
3)Inside instance method by using class name 
4)Inside classmethod by using either class name or cls variable (@classmethod)
5)Inside static method by using class name (@staticmethod)

class Test:   
     a=10   
    def __init__(self):   
         Test.b=20   
    def m1(self):   
     Test.c=30   

   @classmethod   
    def m2(cls):   
         cls.d1=40   
        Test.d2=400  
 
  @staticmethod   
   def m3():   
   Test.e=50   
 
print(Test.__dict__)   
t=Test()   
print(Test.__dict__)   
t.m1()   
print(Test.__dict__)   
Test.m2()   #calling class method
print(Test.__dict__)   
Test.m3()   #calling static method
print(Test.__dict__)   
Test.f=60    #creating static variable outside the class using className
print(Test.__dict__) 




  
How to access Static Variables: 
1)inside constructor: by using either self or classname 
2)inside instance method:  by using either self or classname 
3)inside class method: by using either cls variable or classname 
4)inside static method: by using classname 
5)From outside of class: by using either object reference or classname 
 
class Test: 
   a=10 
  def __init__(self): 
   print(self.a) 
   print(Test.a) 

 def m1(self): 
   print(self.a) 
   print(Test.a) 

@classmethod 
  def m2(cls): 
     print(cls.a) 
     print(Test.a) 

@staticmethod 
   def m3(): 
   print(Test.a) 

t=Test() 
print(Test.a) 
print(t.a) 
t.m1() 
t.m2() 
t.m3()




Where we can modify the Value of Static Variable: 
Anywhere either with in the class or outside of class we can modify by using classname.
 But inside class method, by using cls variable. 
 
class Test: 
 a=777 

  @classmethod 
  def m1(cls): 
   cls.a=888 
  
   @staticmethod 
   def m2(): 
   Test.a=999 
   
print(Test.a) 
Test.m1() 
print(Test.a) 
Test.m2() 
print(Test.a)
#t.a=4343



777 
888 
999 
 
***** 
If we change the Value of Static Variable by using either self OR
Object Reference Variable:	 
If we change the value of static variable by using either self or object reference variable, then the value of static variable won't be changed, just a new instance variable with that name will be added to that particular object. 
 
class Test: 
2) a=10 
3) def m1(self): 
4) self.a=888
 t1=Test() 
6) t1.m1() 
7) print(Test.a) 
8) print(t1.a) 



  
Output 
10
888 
 
1) class Test: 
2) x=10 
3) def __init__(self): 
4) self.y=20 
5) 
6) t1=Test() 
7) t2=Test() 
8) print('t1:',t1.x,t1.y) 
9) print('t2:',t2.x,t2.y) 
10)t1.x=888 
11)t1.y=999 
12) print('t1:',t1.x,t1.y) 
13) print('t2:',t2.x,t2.y) 
Output
t1: 10 20
t2: 10 20
t1: 888 999
t2: 10 20
888 20 
 
 
class Test: 
2) a=10 
3) def __init__(self): 
4) self.b=20 
5) t1=Test() 
6) t2=Test() 
7) Test.a=888 
8) t1.b=999 
9) print(t1.a,t1.b) 
10) print(t2.a,t2.b) 
Output
888 999
888 20

 
 
How to Delete Static Variables of a Class: 
1)We can delete static variables from anywhere by using the following 
  syntax del   classname.variablename 
 
2)But inside classmethod we can also use cls variable 
del   cls.variablename 
 
Example:  
****Note:  
By using object reference variable/self we can read static variables, but we cannot modify or delete. 
If we are trying to modify, then a new instance variable will be added to that particular object. 
t1.a = 70 
If we are trying to delete then we will get error. 
  
Example: 
 
We can modify or delete static variables only by using classname or cls variable. 




import sys   
class Customer:   
	''' Customer class with bank operations.. '''   
     bankname='BlueYBANK'   
     def __init__(self,name,balance=0.0):   
     self.name=name   
     self.balance=balance   
    
    def deposit(self,amt):   
	self.balance=self.balance+amt   
	print('Balance after deposit:',self.balance)   
   
    def withdraw(self,amt):   
       if amt>self.balance:   
       		print('Insufficient Funds..cannot perform this operation')   
         	sys.exit() 
       self.balance=self.balance-amt   
       print('Balance after withdraw:',self.balance)  
 
print('Welcome to',Customer.bankname)   
name=input('Enter Your Name:')   
c=Customer(name)
 
while True:   
	print('d-Deposit \nw-Withdraw \ne-exit') 
	option=input('Choose your option:')   
	if option=='d' or option=='D':   
		amt=float(input('Enter amount:'))   
		c.deposit(amt)   
	elif option=='w' or option=='W':   
		amt=float(input('Enter amount:'))   
		c.withdraw(amt)   
	elif option=='e' or option=='E':   
		print('Thanks for Banking')   
		sys.exit()   
	else:   
	print('Invalid option..Plz choose valid option')   

Output: 

py test.py 
Welcome to RameshBANK Enter Your Name:Ramesh d-Deposit w-Withdraw 
e-exit 
 
Choose your option:d 
Enter amount:10000 Balance after deposit: 10000.0 d-Deposit w-Withdraw 
e-exit 
 
Choose your option:d 
Enter amount:20000 Balance after deposit: 30000.0 d-Deposit w-Withdraw 
e-exit 
 
Choose your option:w 
Enter amount:2000 Balance after withdraw: 28000.0 d-Deposit w-Withdraw 
e-exit 
 
Choose your option:r Invalid option..Plz choose valid option d-Deposit w-Withdraw 
e-exit 
 
Choose your option:e 
Thanks for Banking 




 
Local Variables: 
==================
We can declare variables inside a method directly,such type of variables are called local variable or temporary variables. 

Local variables will be created at the time of method execution and destroyed once method completes. 
Local variables of a method cannot be accessed from outside of method. 
 
Ex:
===
class Test: 

 def m1(self): 
   a=1000   #local variable
   print(a) 
 def m2(self): 
  b=2000    #local variable
  print(b) 
 

t=Test() 
t.m1() 
t.m2() 
 
Ex:2
-----
class Test: 
	def m1(self): 
		a=1000 
		print(a) 
	def m2(self): 
		b=2000 
		print(a) #NameError: name 'a' is not defined 
		print(b) 


t=Test() 
t.m1() 
t.m2()



Types of Methods:
Inside Python class 3 types of methods are allowed
1) Instance Methods
2) Class Methods
3) Static Methods

1)Instance Methods:
==================
Inside method implementation if we are using instance variables then such type of 
methods are called instance methods. 
 Inside instance method declaration, we have to pass self variable. 
def m1(self):
 By using self variable inside method we can able to access instance variables.
Within the class we can call instance method by using self variable and from outside of 
the class we can call by using object reference.

ex:
class Student: 

def __init__(self,name,marks): 
  self.name=name 
  self.marks=marks 

def display(self): 
   print('Hi',self.name) 
   print('Your Marks are:',self.marks) 

def grade(self): 
  if self.marks>=60: 
  	print('You got First Grade') 
  elif self.marks>=50: 
  	print('Yout got Second Grade') 
  elif self.marks>=35: 
  	print('You got Third Grade') 
  else: 
  	print('You are Failed') 

n=int(input('Enter number of students:')) 
for i in range(n): 
	name=input('Enter Name:') 
  	marks=int(input('Enter Marks:')
  	s= Student(name,marks) 
	s.display() 
	s.grade() 
	print()



Class Methods:
===============
Inside method implementation if we are using only class variables (static variables), 
then such type of methods we should declare as class method.

We can declare class method explicitly by using @classmethod decorator. 

For class method we should provide cls variable at the time of declaration
We can call classmethod by using classname or object reference variable

ex:
class Animal: 
 	legs=4 
 	@classmethod 
 	def walk(cls,name): 
 		print('{} walks with {} legs...'.format(name,cls.legs)) 


Animal.walk('Dog') 
Animal.walk('Cat') 


Program to track the Number of Objects created for a Class:
===========================================================
class Test: 
	count=0 
	def __init__(self): 
		Test.count =Test.count+1 

	@classmethod 
	def noOfObjects(cls): 
		print('The number of objects created for test class:',cls.count) 
 
t1=Test() 
t2=Test() 
Test.noOfObjects() 
t3=Test() 
t4=Test() 
t5=Test() 
Test.noOfObjects()




Static Methods:
================
In general these methods are general utility methods.
Inside these methods we won't use any instance or class variables.
Here we won't provide self or cls arguments at the time of declaration.
We can declare static method explicitly by using @staticmethod decorator
We can access static methods by using classname or object reference

Ex:
===

class Test: 

	@staticmethod 
	def add(x,y): 
		print('The Sum:',x+y)
	
	@staticmethod 
	def product(x,y): 
		print('The Product:',x*y) 
 
	@staticmethod 
	def average(x,y): 
		print('The average:',(x+y)/2) 

t1=Test()

t1.add(10,50)
t1.product(50,30)
t1.average(40,40)



Note:
=====
In general we can use only instance and static methods.
Inside static method we can access class level variables by using class name.

Class methods are most rarely used methods in python.




Garbage Collection
==================
In old languages like C++, programmer is responsible for both creation and destruction 
of objects.Usually programmer taking very much care while creating object, but 
nEglecting destruction of useless objects. 

Because of his nEglectance, total memory 
can be filled with useless objects which creates memory problems and total 
application will be down with Out of memory error.

But in Python, We have some assistant which is always running in the background to 
destroy useless objects.Because this assistant the chance of failing Python program 
with memory problems is very less. This assistant is nothing but Garbage Collector.

Hence the main objective of Garbage Collector is to destroy useless objects.

If an object does not have any reference variable then that object eligible for Garbage 
Collection.

How to enable and disable Garbage Collector in our Program:
By default Gargbage collector is enabled, but we can disable based on our requirement. 
In this context we can use the following functions of gc module.

 gc.isenabled()  Returns True if GC enabled
 gc.disable() To disable GC explicitly
 gc.enable() To enable GC explicitly

import gc 
print(gc.isenabled()) 
gc.disable() 
print(gc.isenabled()) 
gc.enable() 
print(gc.isenabled())


Destructors:
============
Destructor is a special method and the name should be __del__

Just before destroying an object Garbage Collector always calls destructor to perform 
clean up activities (Resource deallocation activities like close database connection etc).

Once destructor execution completed then Garbage Collector automatically destroys 
that object.

Note: 
=====
The job of destructor is not to destroy object and it is just to perform clean up 
activities.

 import time 
 class Test: 
	def __init__(self): 
		print("Object Initialization...") 
	def __del__(self): 
	print("Fulfilling Last Wish and performing clean up activities...") 
 
t1=Test() 
t1=None 
time.sleep(5) 
print("End of application")



Passing Members of One Class to Another Class:
===============================================
We can access members of one class inside another class.

class Employee: 
	def __init__(self,eno,ename,esal): 
		self.eno=eno 
		self.ename=ename 
		self.esal=esal 

	def display(self): 
		print('Employee Number:',self.eno) 
		print('Employee Name:',self.ename) 
		print('Employee Salary:',self.esal) 

class Test: 

        @staticmethod
	def modify(emp): 
		emp.esal=emp.esal+10000 
		emp.display() 


e=Employee(100,'VAMSHI',10000) 

Test.modify(e)

Exercise:
==========
1. Write a Python program to create a person class. Include attributes  like name, country and date of birth. Implement a method to  determine the person’s age. 

Create a class Person with calculate_age 

The output of the program:

 Person :1
 Name    : Abhitabh bachan
 country : Maharashtra
 Date of birth :1961-11-12
 Age : ----


2.Write a Python program to create a class representing a shopping cart. 
Include methods for adding and removing items, and calculating the total price. 

Solution: Create a class named as ShoppingCart with functions add_item,remove_item, and  calculate_total.

The output of the program:

Current Items in cart:
papya -100
Guava -200
Orange -150
Total Quantity: 450

Updated Item in Cart after removing orange
papaya -100
Guava -200
Total Quantity:300

Inheritance(is-a) :
===================
The process of inheriting the properties of the parent class into a child class is called inheritance. The existing class is called a base class or parent class and the new class is called a subclass or child class or derived class.

The main purpose of inheritance is the reusability of code because we can use the existing class to create a new class instead of creating it from scratch.

In inheritance, the child class acquires all the data members, properties, and functions from the parent class. Also, a child class can also provide its specific implementation to the methods of the parent class.

Inheritance is also called as a is-a relation

For example, In the real world, Car is a sub-class of a Vehicle class. We can create a Car by inheriting the properties of a Vehicle such as Wheels, Colors, Fuel tank, engine, and add extra properties in Car as required.

The type of inheritance are listed below:

Single inheritance:
-------------------
In single inheritance, a child class inherits from a single-parent class. Here is one child class and one parent class.

class Parent:
        name="bluey"
	def m1(self):
		print("Inside the parent class")

class Child(Parent):
	def m2(self):
		print("Inside the child Class")



c=Child()
c.m2()  #calling child class function
c.m1() #calling Parent class function
print(c.name)




Multiple Inheritance
--------------------:
In multiple inheritance, one child class can inherit from multiple parent classes. So here is one child class and multiple parent classes.

Ex: Person is  a class
    Company is a class
    Employee is a child class of Person,Company.


class Person:
	def per_info(self,name,age):		
		print("person information: ",name,age)

	def display():
		print("Inside the Person class")

class Company:
	def comp_info(self,company,loc):
		print("company info: ",company,loc)

	def display():
		print("Inside the Company class")

class Employee(Person,Company):
	def emp_info(self,salary,addrs):
		print("Employee info:",salary,addrs)


eobj = Employee()
eobj.per_info("martin",36)
eobj.comp_info("bluey","hyd")
eobj.emp_info(10000,"Mumbai")
eobj.display()

Note:
====
if the same method is inherited from the both parent classes,then python will
always consider the order of parent class in the declaration of the child class.

class Employee(Person,Company) --> display() from Person is considered.
class Employee(Company,Person) --> display() from Company is considerd.



Multilevel inheritance
-----------------------
In multilevel inheritance, a class inherits from a child class or derived class. Suppose three classes A, B, C. A is the superclass, B is the child class of A, C is the child class of B. In other words, we can say a chain of classes is called multilevel inheritance.

Ex:
---
class Vehicle:
	def veh_info(self):
		print("inside vechicle class)

class Car(Vehicle):
	def car_info(self):
		print("Inside Car class")

class SportsCar(Car):
	def sprt_info(self):
		print("Inside the Sports Cars")


sc=SportsCar()
sc.sprt_info()
sc.car_info()
sc.veh_info()

Hierarchical Inheritance:
-------------------------
In Hierarchical inheritance, more than one child class is derived from a single parent class. In other words, we can say one parent class and multiple child classes.


ex: let see Vehicle is parent class, Car and Trunck are the child classes of Vehicle


class Vehicle:
	def veh_info(self):
		print("inside vechicle class)

class Car(Vehicle):
	def car_info(self,name):
		print("The car name is : ",name)

class Truck(Vehicle):
	def truck_info(self,name):
		print("The truck name is : " name)


c=Car()
c.car_info("Ford")
c.veh_info()

t=Truck()
t.truck_info("Mahendra")
t.veh_info()



Hybrid Inheritance
-------------------
When inheritance is consists of multiple types or a combination of different inheritance is called hybrid inheritance.

Ex:
====

class Vehicle:
	def veh_info(self):
		print("inside vechicle class)

class Car(Vehicle):
	def car_info(self,name):
		print("The car name is : ",name)

class Truck(Vehicle):
	def truck_info(self,name):
		print("The truck name is : " name)


class SportsCar(Car,Vehicle):     #multiple inheritance
	def sprt_info(self,name):
		print("The Sports Car name is : ",name)


c=Car()
c.car_info("Ford")
c.veh_info()

t=Truck()
t.truck_info("Mahendra")
t.veh_info()

sc=SportsCar()
sc.sprt_info("ferari")
sc.car_info("BMW")
sc.veh_info()


super():
-------
super() is a built-in method which is useful to call the super class constructors,variables 
and functions from the child class.

Ex:
====

class Person:
	def __init__(self):
		print("Constructor inside Person class")

	def per_info(self,name,age):
		print("The person info: ",name,age)

class Employee(Person):
	def __init__(self):
		super().__init__() #calling constructor of parent class
		print("Constructor inside Employee class")

	def emp_info(self,salary,loc)
		super().per_info("marin",45)
		print("employee info ",salary,loc)

e=Employee()

e.emp_info(4000,"boston")


By Composition (Has-A Relationship):
=====================================
By using Class Name or by creating object we can access members of one class inside 
another class is nothing but composition (Has-A Relationship).

The main advantage of Has-A Relationship is Code Reusability.


class Car:
	def __init__(self,name,model):
		self.name=name
		self.model=model
	def getInfo(self):
		print("Car name is {} and model is {}".format(self.name,self.model))

class Employee:
	def __init__(self,eno,ename,loc,car):
		self.eno=eno
		self.ename=ename
		self.loc=loc
		self.car=car
        def getEmpInfo(self):
                print("employee No: {} ,EmpName is : {} ,locaion is : 					 		{}".format(self.eno,self.ename,self.loc))
                
                 c=self.car
                 c.getInfo(self)

cobj = Car("Maruti",2020)
eobj = Employee(1001,"smith","hyd",cobj)

eobj.getEmpInfo()


IS-A vs HAS-A Relationship:
===========================
If we want to inherit existing functionality with some more extra functionality then we 
should go for IS-A Relationship.

If we dont want to inherit and just we have to use existing functionality then we 
should go for HAS-A Relationship.

Eg: Employee class inherits Person class Functionality But Employee class just uses Car 
functionality but not inheriting         

	Person(name,age)
	|
	|is-a
	|
	Employee(salary,addrs)  ----- Has-a ----- Car(name,model,color)


class Person:
	def __init__(self,name,age):
		self.name=name
		self.age=age
        def getPerInfo(self):
		print("Name is : {}, age is : {}".format(self.name,self.age))

class Car:
	def __init__(self,name,model,color):
		self.name=name
                self.model=model
		self.color=color

	def getCarInfo(self):
		print("Car Name is :{ },Model : { },Color : {}".format(self.name,self.model,self.color))

class Employee(Person):
	def __init__(self,name,age,salary,addrs,car):
		super().__init(name,age)
 		self.salary=salary
	        self.addrs=addrs
		self.car=car
        
	def getEmpDetails(self):
            super().getPerInfo()
            print("EmpSalary is  {},address is {} ".format(self.salary,self.addrs))
            self.car.getCarInfo()

c=Car("Maruti",2020,"grey")
eobj = Employee("smith",46,4000,"boston",c)

eobj.getEmpDetails()
	     
                 
          
Examples on super:
==================
class P: 
	a=10 
	def __init__(self): 
		self.b=10 
	def m1(self): 
		print('Parent instance method') 
	@classmethod 
	def m2(cls): 
		print('Parent class method') 

	@staticmethod 
	def m3(): 
	print('Parent static method') 
 
class C(P): 
	a=888 
	def __init__(self): 
		self.b=999 
		super().__init__()
		print(super().a) 
		super().m1() 
		super().m2() 
		super().m3() 

c=C() 

Output:
10
Parent instance method
Parent class method
Parent static method

In the above example we are using super() to call various members of Parent class.


How to Call Method of a Particular Super Class:
===============================================
We can use the following approaches

1) super(D, self).m1()
 It will call m1() method of super class of D.

 note: the super class of specified class will be called, class C is called. The mentioned class is D and its super class is C.

2) A.m1(self)
 It will call A class m1() method

Ex:
===
class A: 
	def m1(self): 
		print('A class Method') 

class B(A): 
	def m2(self): 
		print('B class Method') 

class C(B): 
	def m3(self): 
		print('C class Method') 


class D(C): 
	def m4(self): 
		print('D class Method') 

class E(D): 
	def m5(self): 
		A.m1(self) 
		super(D,self).m3() 
        	
e=E() 
e.m5()




Important Points about super():
=========================================
Case-1: From child class we are not allowed to access parent class instance variables by 
using super(), Compulsory we should use self only.

But we can access parent class static variables by using super()

class P: 
	a=10 
	def __init__(self): 
		self.b=20

class C(P): 
	def m1(self): 
		print(super().a)#valid 
		print(self.b)#valid 
		print(super().b)#invalid 

c=C() 
c.m1()

Output:
=======
10
20
AttributeError: 'super' object has no attribute 'b'

Case-2: From child class constructor and instance method, we can access parent class 
instance method, static method and class method by using super()

Ex:
===
class P: 
	def __init__(self): 
		print('Parent Constructor') 
	def m1(self): 
		print('Parent instance method')
	@classmethod 
	def m2(cls): 
		print('Parent class method')

	@staticmethod 
	def m3(): 
		print('Parent static method')

class C(P): 
	def __init__(self): 
		super().__init__() 
		super().m1() 
		super().m2() 
		super().m3()
	
	def m4(self): 
		super().__init__() 
		super().m1() 
		super().m2() 
		super().m3()

c=C() 
c.m4() 


Case-3: From child class, class method we cannot access parent class instance methods 
and constructors by using super() . But we can access 
parent class static and class methods

Ex:
----
class P: 
	def __init__(self): 
		print('Parent Constructor') 

	def m1(self): 
		print('Parent instance method') 

	@classmethod 
	def m2(cls): 
		print('Parent class method') 

	@staticmethod 
	def m3(): 
		print('Parent static method') 

class C(P): 
	
	@classmethod 
	def m4(cls): 
		#super().__init__()--->invalid 
		#super().m1()--->invalid 
		super().m2() 
		super().m3()

C.m4()



How to Call Parent Class Static Method from Child Class Static 
Method by using super():
--------------------------------------------------------------
class A:
    @staticmethod
    def m1():
        print('Parent static method')

class B(A):
    @staticmethod
    def m2():
        super(B,B).m1()


B.m2()

Polymorphism:
-------------
poly means many. Morphs means forms.
Polymorphism means 'Many Forms'.

Eg2: + operator acts as concatenation and arithmetic addition
Eg3: * operator acts as multiplication and repetition operator
Eg4: The Same method with different implementations in Parent class and child 
classes.(overriding)
Related to Polymorphism the following 4 topics are important

1) Duck Typing Philosophy of Python

2) Overloading
	1) Operator Overloading
	2) Method Overloading
	3) Constructor Overloading

3) Overriding
	1) Method Overriding
	2) Constructor Overriding

1) Duck Typing Philosophy of Python:
====================================
In Python we cannot specify the type explicitly. Based on provided value at 
runtime the type will be considered automatically. 
Hence Python is considered as Dynamically Typed Programming Language.

def f1(obj):
obj.talk()

what is the Type of obj? We cannot decide at the Beginning. 
At Runtime we can Pass any Type. Then how we can decide the Type?

At runtime if 'it walks like a duck and talks like a duck,it must be duck'. 
Python follows this principle. This is called Duck Typing Philosophy of Python.


class Duck: 
	def talk(self): 
		print('Quack.. Quack..') 

class Dog: 
	def talk(self): 
		print('Bow Bow..') 

class Cat: 
	def talk(self): 
		print('Moew Moew ..') 

class Goat: 
	def talk(self): 
		print('Myaah Myaah ..') 

def f1(obj): 
	obj.talk() 

l=[Duck(),Cat(),Dog(),Goat()] 

for obj in l: 
	f1(obj)

The problem in this approach is if obj does not contain talk() method then we will get AttributeError

Ex:

class Duck: 
	def talk(self): 
		print('Quack.. Quack..') 

class Dog: 
	def bark(self): 
		print('Bow Bow..') 

def f1(obj): 
	obj.talk() 

d=Duck() 
f1(d) 
d=Dog() 
f1(d) 


But we can solve this problem by using hasattr() function.
hasattr(obj,'attributename')  attributename can be Method Name OR Variable Name

Demo Program with hasattr() Function:

class Duck: 
	def talk(self): 
		print('Quack.. Quack..') 

class Human: 
	def talk(self): 
		print('Hello Hi...') 

class Dog: 
	def bark(self): 
		print('Bow Bow..') 

def f1(obj): 
	if hasattr(obj,'talk'): 
		obj.talk() 
	elif hasattr(obj,'bark'): 
		obj.bark()

d=Duck() 
f1(d) 
 
h=Human() 
f1(h) 

d=Dog() 
f1(d) 


2) Overloading
 We can use same operator or methods for different purposes.
Eg 1: + operator can be used for Arithmetic addition and String concatenation
 print(10+20)#30
 print('blue'+'soft')
Eg 2: * operator can be used for multiplication and string repetition purposes.
 print(10*20)#200
 print('blue'*3)#blueblueblue
Eg 3: We can use deposit() method to deposit cash or cheque or dd
 deposit(cash)
 deposit(cheque)
 deposit(dd)

There are 3 types of Overloading
1) Operator Overloading
2) Method Overloading
3) Constructor Overloading


1)Operator Overloading:

We can use the same operator for multiple purposes, which is nothing but operator 
overloading.

Python supports operator overloading.

Eg 1: + operator can be used for Arithmetic addition and String concatenation
 print(10+20)#30
 print('blue'+'soft')#bluesoft

Eg 2: * operator can be used for multiplication and string repetition purposes.
 print(10*20)#200
 print('bluey'*3)#blueyblueybluey


Demo program to use + operator for our class objects:

class Book: 
	def __init__(self,pages): 
		self.pages=pages 
 
b1=Book(100)
b2=Book(200) 
print(b1+b2) 


We can overload + operator to work with Book objects also. i.e Python supports 
Operator Overloading.

For every operator Magic Methods are available. To overload any operator we have to 
override that Method in our class. 

Internally + operator is implemented by using __add__() method.This method is called 
magic method for + operator. We have to override this method in our class. 

Ex:

Demo Program to Overload + Operator for Our Book Class Objects:

class Book: 
	def __init__(self,pages): 
		self.pages=pages 
 
	def __add__(self,other): 
		return self.pages+other.pages 
 
b1=Book(100) 
b2=Book(200) 
print('The Total Number of Pages:',b1+b2)

Output: The Total Number of Pages: 300

The following is the list of operators and corresponding magic methods.
1) +  object.__add__(self,other)
2) -  object.__sub__(self,other)
3) *  object.__mul__(self,other)
4) /  object.__div__(self,other)
5) // object.__floordiv__(self,other)
6) %  object.__mod__(self,other)
7) ** object.__pow__(self,other)
8) += object.__iadd__(self,other)
9) -= object.__isub__(self,other)
10) *= object.__imul__(self,other)
11) /= object.__idiv__(self,other)
12) //= object.__ifloordiv__(self,other)


Program to Overload Multiplication Operator to Work on Employee Objects:

class Employee: 
	def __init__(self,name,salary): 
		self.name=name 
		self.salary=salary
 
	def __mul__(self,other): 
		return self.salary*other.days
class TimeSheet: 
	def __init__(self,name,days): 
		self.name=name 
		self.days=days 

e=Employee('Durga',500) 
t=TimeSheet('Durga',25) 

print('This Month Salary:',e*t) 
Output: This Month Salary: 12500


2)Method Overloading:

If 2 methods having same name but different type of arguments then those methods 
are said to be overloaded methods.
 Eg: m1(int a)
 m1(double d)

But in Python Method overloading is not possible.
If we are trying to declare multiple methods with same name and different number of 
arguments then Python will always consider only last method.

Demo Program:

class Test: 
	def m1(self): 
		print('no-arg method') 
	def m1(self,a): 
		print('one-arg method') 
	def m1(self,a,b): 
		print('two-arg method') 
 
t=Test() 
#t.m1() 
#t.m1(10) 
t.m1(10,20) 


Output: two-arg method
In the above program python will consider only last method.


class Test:
	def m1(self,*n):
		sum=0
		for i in n:
			sum+=i
		print(sum)

t=Test()

t.m1(10,20)
t.m1(10,20,30)

3)Constructor Overloading:

If 2 constructors having same name but different type of arguments then those methods 
are said to be overloaded constructors.
 Eg:
 __init__(self)
__init__(self,name,age)

But in Python constructor overloading is not possible.
If we are trying to declare multiple constructors with same name and different number of 
arguments then Python will always consider only last constructor.

Ex:

class Test:

	def __init__(self):
		print("default constructor")
	def __init__(self,name):
		print("one argument constructor",name)

	def __init__(self,name,age):
		print("two argument constructor",name,age)

t=Test()
t1=Test("smith")
t2=Test("smith",65)


Above code will get TypeError

DEFAULT ARGUMENT CONSTRUCTOR
----------------------------
class Test:

	def __init__(self,n=0,n1=1,n2=2):
		print("constrcutor with default value parameters",n,n1,n2)

t=Test()
t1=Test(10,20)
t2=Test(30,40,50)


Variable Argument Constructor:
------------------------------

class Test:

	def __init__(self,*n):
		for i in n:
			print(i)


t=Test("smith",65)
t1=Test(10,20)
t2=Test(30,40,50)


methodOverriding:
=================
What ever members available in the parent class are bydefault available to the child 
class through inheritance. If the child class not satisfied with parent class 
implementation then child class is allowed to redefine that method in the child class 
based on its requirement. This concept is called overriding.

Overriding concept applicable for both methods and constructors.
Ex:
--


class Parent:
	def m1(self):
		print("we are in parent class m1 method")

class Child(Parent):
	def m1(self):
		print("we are in child class m1 method")
		//super().m1()
   

c=Child()

c.m1()


Demo Program for Constructor Overriding:
========================================
class P: 
	def __init__(self): 
		print('Parent Constructor')  

class C(P): 
	def __init__(self):
		print('Child Constructor') 

c=C()


exercises:
==========
Check type,issub(),isinstance()of an object:

Write a program to determine which class a given Bus object belongs to.

Given:

class Vehicle:
    def __init__(self, name, mileage, capacity):
        self.name = name
        self.mileage = mileage
        self.capacity = capacity

class Bus(Vehicle):
    pass

School_bus = Bus("School Volvo", 12, 50)


2)Read text file into a variable and replace all newlines with space
Given: Assume you have a following text file (sample.txt).

Line1
line2
line3
line4
line5

Expected Output:

Line1 line2 line3 line4 line5


Public, Protected and Private Attributes:
===========================================
By default every attribute is public. 
We can access from anywhere either within the class 
or from outside of the class.

Eg: name = 'ramu'

Protected attributes can be accessed within the class anywhere but from outside of the 
class only in child classes.We can specify an attribute as protected by prefexing with _symbol.
Syntax: _variablename = value
Eg: _name='ramu'

But is is just convention and in reality does not exists protected attributes.

private attributes can be accessed only within the class.i.e from outside of the class we 
cannot access. We can declare a variable as private explicitly by prefexing with 2 
underscore symbols.

syntax: __variablename=value

__name='ramu'


class Test: 
	x=10 #public
	_y=20  #protected
	__z=30  #private
	def m1(self): 
		print(Test.x) 
		print(Test._y) 
		print(Test.__z) 

t=Test() 
t.m1() 

print(Test.x) 
print(Test._y) 
print(t._Test__z)


How to Access Private Variables from Outside of the Class:
-----------------------------------------------------------
We cannot access private variables directly from outside of the class.
But we can access indirectly as follows objectreference._classname__variablename

class Test: 
	def __init__(self):
		self.__x=10 

t=Test() 
print(t._Test__x)


Abstract Method:
================
Sometimes we don't know about implementation, still we can declare a method. 
Such types of methods are called abstract methods.i.e abstract method has only declaration 
but not implementation.

In python we can declare abstract method by using @abstractmethod decorator as 
follows.
	@abstractmethod
	def m1(self): pass

@abstractmethod decorator present in abc module. 
Hence compulsory we should import abc module,otherwise we will get error.
abc  abstract base class module


class Test: 
	@abstractmethod 
	def m1(self): 
		pass 
NameError: name 'abstractmethod' is not defined

Ex:
---
from abc import abstractmethod

class Test: 
	@abstractmethod 
	def m1(self): 
		pass 

Note:
----
Child classes are responsible to provide implemention for parent class abstract methods.


Abstract class:
----------------
Some times implementation of a class is not complete,such type of partially 
implementation classes are called abstract classes. Every abstract class in Python should 
be derived from ABC class which is present in abc module.

Case-1:
from abc import * 
	class Test: 
		pass 

t=Test() 

In the above code we can create object for Test class b'z it is concrete class and it does not 
conatin any abstract method.

Case-2:

from abc import * 
	class Test(ABC): 
		pass 
 
t=Test()  

In the above code we can create object, even it is derived from ABC class,b'z it does not 
contain any abstract method.


Case-3:

from abc import * 
	class Test(ABC): 
		@abstractmethod 
		def m1(self): 
			pass 


t=Test() 


TypeError: Can't instantiate abstract class Test with abstract methods m


Case-4:

from abc import * 
class Test: 
	@abstractmethod 
	def m1(self): 
		pass 

t=Test() 

We can create object even class contains abstract method b'z we are not extending ABC 
class.


Case-5:
from abc import * 
class Test: 
	@abstractmethod 
	def m1(self): 
		print('Hello') 
 
t=Test() 
t.m1() 

Output: Hello

Conclusion: If a class contains atleast one abstract method and if we are extending ABC 
class then instantiation is not possible.


Interfaces In Python:
=====================
In general if an abstract class contains only abstract methods such type of abstract class is 
considered as interface.

Ex:
---
from abc import * 
class DBInterface(ABC): 
	@abstractmethod 
	def connect(self):pass 
 	
	@abstractmethod 
	def disconnect(self):pass 
 
class Oracle(DBInterface): 
	def connect(self): 
		print('Connecting to Oracle Database...') 

	def disconnect(self): 
	print('Disconnecting to Oracle Database...')



exercise:
=========
Write a Python program to search some literals strings in a string. 
Go to the editor Sample text : 'The quick brown fox jumps over the lazy dog.' 

Searched words : 'fox', 'dog', 'horse'

REGULAR EXPRESSIONS:
====================
If we want to represent a group of Strings according to a particular format/pattern 
then we should go for Regular Expressions.

i.e Regualr Expressions is a declarative mechanism to represent a group of Strings 
accroding to particular format/pattern.

Eg 1: We can write a regular expression to represent all mobile numbers
Eg 2: We can write a regular expression to represent all mail ids

We can develop Regular Expression Based applications by using python module: re

This module contains several inbuilt functions to use Regular Expressions very easily in 
our applications.

compile():
----------
Returns Module contains compile() Function to compile a Pattern into RegexObject.
 pattern = re.compile("ab")

finditer():
-----------
 Returns an Iterator object which yields Match object for every Match
 matcher = pattern.finditer("abaababa")

On Match object we can call the following methods.
1) start() -> Returns start index of the match
2) end() -> Returns end+1 index of the match
3) group() -> Returns the matched string

import re 
count=0 
pattern=re.compile("ab") 
matcher=pattern.finditer("abaababa") 
for match in matcher: 
	count+=1 
	print(match.start(),"...",match.end(),"...",match.group()) 
	print("The number of occurrences: ",count)

Output:
0 ... 2 ... ab
3 ... 5 ... ab
5 ... 7 ... ab

The number of occurrences: 3

Ex:
We can pass pattern directly as argument to finditer() function.

import re 
count=0 
matcher=re.finditer("ab","abaababa") 
for match in matcher: 
	count+=1 
	print(match.start(),"...",match.end(),"...",match.group()) 
	print("The number of occurrences: ",count)

Output:
0 ... 2 ... ab
3 ... 5 ... ab
5 ... 7 ... ab
The number of occurrences: 3

Character Classes:
------------------
We can use character classes to search a group of characters

1) [abc] -> Either a OR b OR c
2) [^abc] -> Except a and b and c
3) [a-z] -> Any Lower case alphabet symbol
4) [A-Z] -> Any upper case alphabet symbol
5) [a-zA-Z] -> Any alphabet symbol
6) [0-9] -> Any digit from 0 to 9
7) [a-zA-Z0-9] -> Any alphanumeric character
8) [^a-zA-Z0-9] -> Except alphanumeric characters(Special Characters)


Pre defined Character Classes:
1) \s -> Space character
2) \S -> Any character except space character
3) \d -> Any digit from 0 to 9
4) \D -> Any character except digit
5) \w -> Any word character [a-zA-Z0-9]
6) \W -> Any character except word character (Special Characters)
7) . ->  Any character including special character



Qunatifiers:
-----------
We can use quantifiers to specify the number of occurrences to match.
1) a ->      Exactly one 'a'
2) a+ ->     Atleast one 'a'
3) a* ->     Any number of a's including zero number
4) a? ->     Atmost one 'a' ie either zero number or one number
5) a{m} ->   Exactly m number of a's
6) a{m,n} -> Minimum m number of a's and Maximum n number of a'

1) ^x -> It will check whether target string starts with x OR not.
2) x$ -> It will check whether target string ends with x OR not.


Important Functions of Remodule:
---------------------------------
1) match()
2) fullmatch()
3) search()
4) findall()
5) finditer()
6) sub()
7) subn()
8) split()
9) compile()

match():
--------
We can use match function to check the given pattern at beginning of target string.
If the match is available then we will get Match object, otherwise we will get None.

import re 
s=input("Enter pattern to check: ") 
m=re.match(s,"abcabdefg") 

if m!= None: 
	print("Match is available at the beginning of the String") 
	print("Start Index:",m.start(), "and End Index:",m.end()) 
else: 
	print("Match is not available at the beginning of the String")



fullmatch():
-------------
We can use fullmatch() function to match a pattern to all of target string. i.e complete 
string should be matched according to given pattern.

If complete string matched then this function returns Match object otherwise it 
returns None

import re 
s=input("Enter pattern to check: ")
m=re.fullmatch(s,"ababab") 

if m!= None: 
	print("Full String Matched") 
else: 
	print("Full String not Matched")


search():
---------
We can use search() function to search the given pattern in the target string.
If the match is available then it returns the Match object which represents first 
occurrence of the match.

If the match is not available then it returns None

import re 
s=input("Enter pattern to check: ") 
m=re.search(s,"abaaaba") 
if m!= None: 
	print("Match is available") 
	print("First Occurrence of match with start index:",m.start(),"and end index:",m.end()) 
else: 
	print("Match is not available")


findall():
----------
To find all occurrences of the match.
This function returns a list object which contains all occurrences.

import re 
l=re.findall("[0-9]","a7b9c5kz") 
print(l) 

Output: ['7', '9', '5']


finditer():
-----------
Returns the iterator yielding a match object for each match.
On each match object we can call start(), end() and group() functions.

import re 
itr=re.finditer("[a-z]","a7b9c5k8z") 
for m in itr: 
	print(m.start(),"...",m.end(),"...",m.group())


sub():
------
sub means substitution or replacement.
re.sub(regex,replacement,targetstring)

In the target string every matched pattern will be replaced with provided replacement.

import re 
s=re.sub("[a-z]","#","a7b9c5k8z") 
print(s)



subn():
-------
It is exactly same as sub except it can also returns the number of replacements.
This function returns a tuple where first element is result string and second element is 
number of replacements.
(resultstring, number of replacements)

import re 
t=re.subn("[a-z]","#","a7b9c5k8z") 
print(t) 
print("The Result String:",t[0]) 
print("The number of replacements:",t[1]) 



split():
--------
If we want to split the given target string according to a particular pattern then we 
should go for split() function.

This function returns list of all tokens.

import re 
l=re.split(",","sunny,bunny,vinny,rahul,tillu") 
print(l) 
for t in l: 
	print(t)


Ex:2
----
s="Weclome#topyhton#re";

l=re.split('|',s)





^ symbol:
---------
We can use ^ symbol to check whether the given target string starts with our provided 
pattern or not.
Eg: res = re.search("^Learn",s)

If the target string starts with learn then it will return Match object,otherwise returns 
None

import re 
s="Learning Python is Very Easy" 
res=re.search("^Learn",s)

if res != None: 
	print("Target String starts with Learn") 
else: 
	print("Target String Not starts with Learn")



$ symbol:
---------
We can use $ symbol to check whether the given target string ends with our 
provided pattern or not.

Eg: res = re.search("Easy$",s)

If the target string ends with Easy then it will return Match object,otherwise 
returns None.

import re 
s="Learning Python is Very Easy" 
res=re.search("Easy$",s) 

if res != None: 
	print("Target String ends with Easy") 
else: 
	print("Target String Not ends with Easy")


Examples:
---------

Write a Python Program to check whether the given 
 Number is valid Mobile Number OR not?

[789][0-9] [0-9][0-9][0-9][0-9][0-9][0-9][0-9]

or

[789][0-9]{9}

or


[789]\d{9}


solu:-

no=input("Enter the mobileno")
m=re.fullmatch("[789][0-9]{9}",no)
if m!= None:
	print("mobileno is matched")
else:
	print(mobileno is not matched)






Write a Python Program to check whether the given mail id is valid 
gmail id OR not?

soL
---
\w[a-zA-Z0-9_.]*@gmail.com

gm=input("Enter the gmail")
m=re.fullmatch("\\w[a-zA-Z0-9_.]*@gmail.com",gm)
if m!= None:
	print("gmail is matched")
else:
	print(" gmail is not matched")



Write a Python program to match a string that contains only upper and lowercase letters, numbers, and underscores?

# Solution
def text_match(text):
        patterns = '^[a-zA-Z0-9_]*$'
        if re.search(patterns,  text):
                return 'Found a match!'
        else:
                return('Not matched!')

print(text_match("The quick brown fox jumps over the lazy dog."))
print(text_match("Python_Exercises_1"))

Write a Python program to find sequences of lowercase letters joined with a underscore.

# Solution
def text_match(text):
        patterns = '^[a-z]+_[a-z]+$'
        if re.search(patterns,  text):
                return 'Found a match!'
        else:
                return('Not matched!')
 
print(text_match("aab_cbbbc"))
print(text_match("aab_Abbbc"))
print(text_match("Aaab_abbbc"))


Write a pattern for password
1)atleast 8 characters and max 12 
2)It should contain atleast one uppercase
3)It should contain atleast one digit

Generators:
===========
python Generators are used to create the iterators but in a different way. 
Generally, generators are the functions that can return value several times. 

Python, generator functions are those functions that, instead of returning a single value, return an iterable generator object. You can access or read the values returned from the generator function stored inside a generator object one-by-one using a simple loop or using next() or list() methods.

You can create a generator function using the generator() and yield keywords

Let's imagine, if we define a function and we want to return a value in a couple of times, what we entered into that statement. We can do this statement using normal Python and check what happens, take look in below.

def my_func(x):
	return x*2

The above result shows that the function gives the value of x, and it can double only once. But, we can use generators it makes double every time when we called the next() function. 

This process will occur when the yield keyword comes into the picture. The yield keyword is the same as the return keyword in normal Python. But, only differences are yield can call so many times as we would like. 

Let's see an example, how generators will work and how it doubles the value.

def my_generator(x):
	yield x*2
	yield x*4
	yield x*8

The above result shows whatever we gave as an input, it shows the result three times. Take a value 2 and pass it to input and finally, it ends the result as 16. Because of a three-time iteration right. Key takeaways: generators.


Ex:
---
def filter_odd(numbers):

   for number in range(numbers):

       if(number%2!=0):

           yield number 

odd_numbers = filter_odd(20)

print(list(odd_numbers)) #converting generator to list


or
---
def say_gt():
	yield "welcome"
	yield "to"
	yield "python"

or

def allOper(a,b):
	yield (a+b)
	yield (a/b)
        yield (a*b)


l =allOper(10,2)
for res in l:
	print(res)

 









